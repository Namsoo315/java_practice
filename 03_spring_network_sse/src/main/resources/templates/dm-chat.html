<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>DM 채팅 - WebSocket</title>

    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <!-- SockJS -->
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <!-- STOMP (옛날 2.x, 전역: Stomp) -->
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { margin-bottom: 5px; }
        a { text-decoration: none; color: #0074d9; }
        .layout { display: flex; gap: 16px; margin-top: 16px; }
        .sidebar { width: 220px; border: 1px solid #ccc; padding: 10px; }
        .main { flex: 1; }
        .chat-box {
            border: 1px solid #ccc;
            height: 320px;
            overflow-y: auto;
            padding: 8px;
            background: #fafafa;
        }
        .message {
            margin: 4px 0;
            max-width: 70%;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 13px;
        }
        .message.mine {
            margin-left: auto;
            background: #d0ebff;
            text-align: right;
        }
        .message.other {
            margin-right: auto;
            background: #f1f3f5;
            text-align: left;
        }
        .message .meta { font-size: 11px; color: #666; }
        .controls { margin-top: 6px; }
        .controls input { padding: 4px; font-size: 13px; }
        .controls button { padding: 4px 8px; font-size: 13px; margin-left: 4px; }
        pre { background: #f5f5f5; padding: 8px; white-space: pre-wrap; font-size: 12px; }
        label { font-size: 12px; }
        input[type="number"] { width: 80px; }
    </style>
</head>
<body>
<h1>DM 채팅 - WebSocket(STOMP)</h1>
<p><a th:href="@{/}">← 메인으로</a></p>

<div class="layout">
    <div class="sidebar">
        <div>
            <strong>내 정보 (GET /api/auth/me)</strong>
            <pre id="me-info"></pre>
        </div>

        <div style="margin-top: 10px;">
            <strong>쪽지함 설명</strong>
            <p style="font-size: 12px;">
                - 이 화면은 "내게 온 모든 DM" 을 쪽지함 형태로 보여준다.<br>
                - 새 DM은 WebSocket으로 실시간 수신되고, 초기 로딩은 HTTP로 가져온다.
            </p>
        </div>
    </div>

    <div class="main">
        <div class="chat-box" id="dm-chat-box">
            "DM 전체 불러오기" 버튼을 누르거나 새 DM이 오면 표시된다.
        </div>

        <div class="controls" style="margin-top: 10px;">
            <label>수신자 사용자 ID:</label>
            <input type="number" id="dm-receiver-id" placeholder="예: 2" />
            <input type="text" id="dm-input" placeholder="보낼 DM 내용을 입력하세요" style="width: 40%;" />
            <button type="button" onclick="sendDmMessage()">DM 전송</button>
            <button type="button" onclick="loadDmInbox()">DM 전체 불러오기</button>
        </div>

        <div style="margin-top: 8px;">
            <strong>마지막 응답 Raw 데이터</strong>
            <pre id="debug-result"></pre>
        </div>
    </div>
</div>

<script>
    axios.defaults.withCredentials = true;

    let currentUser = null;
    let lastDmMessageId = 0;

    let stompClient = null;
    let stompConnected = false;
    let dmSubscription = null;
    let pendingDmQueue = []; // 연결 전에 보낸 메시지 잠시 보관

    document.addEventListener('DOMContentLoaded', () => {
        // 1) 내 정보 먼저 읽고
        loadMe().then(() => {
            // 2) WebSocket/STOMP 연결 시도
            connectStomp();
            // 3) 초기 DM 로딩
            loadDmInbox();
        });
    });

    function loadMe() {
        return axios.get('/api/auth/me')
            .then(res => {
                currentUser = res.data;
                document.getElementById('me-info').textContent =
                    JSON.stringify(currentUser, null, 2);
                trySubscribeDm(); // 혹시 먼저 연결돼 있으면 구독 시도
            })
            .catch(err => {
                document.getElementById('me-info').textContent =
                    err.response ? JSON.stringify(err.response.data, null, 2) : err.message;
            });
    }

    function connectStomp() {
        const socket = new SockJS('/ws-stomp');
        stompClient = Stomp.over(socket);
        // 필요 없으면 로그 끄기
        // stompClient.debug = null;

        stompClient.connect({}, function (frame) {
            console.log('STOMP Connected: ' + frame);
            stompConnected = true;
            trySubscribeDm();

            // 연결 전에 쌓아둔 DM들 전송
            pendingDmQueue.forEach(({receiverId, payload}) => {
                stompClient.send(`/app/dm/${receiverId}/send`, {}, JSON.stringify(payload));
            });
            pendingDmQueue = [];
        }, function (error) {
            console.error('STOMP error', error);
            stompConnected = false;
        });
    }

    function trySubscribeDm() {
        if (!currentUser || !stompClient || !stompConnected) {
            return;
        }
        if (dmSubscription) {
            return;
        }
        const userId = currentUser.id;
        const destination = `/topic/dm.${userId}`;
        dmSubscription = stompClient.subscribe(destination, function (message) {
            const body = JSON.parse(message.body);
            appendDmMessages([body]);
            document.getElementById('debug-result').textContent =
                JSON.stringify(body, null, 2);
        });
    }

    function loadDmInbox() {
        axios.get('/api/dm/messages')
            .then(res => {
                const box = document.getElementById('dm-chat-box');
                box.innerHTML = '';
                appendDmMessages(res.data);
                scrollToBottom(box);

                document.getElementById('debug-result').textContent =
                    JSON.stringify(res.data, null, 2);
            })
            .catch(err => {
                document.getElementById('dm-chat-box').textContent =
                    err.response ? JSON.stringify(err.response.data, null, 2) : err.message;
            });
    }

    function appendDmMessages(messages) {
        const box = document.getElementById('dm-chat-box');
        messages.forEach(msg => {
            const div = document.createElement('div');
            const mine = currentUser && msg.senderId === currentUser.id;
            div.className = 'message ' + (mine ? 'mine' : 'other');

            const senderName = msg.senderNickname || msg.senderUsername || ('user#' + msg.senderId);
            const time = msg.createdAt || '';
            div.innerHTML =
                `<div class="meta">${mine ? '(나) ' : ''}${senderName} - ${time}</div>` +
                `<div>${escapeHtml(msg.content)}</div>`;

            box.appendChild(div);
            lastDmMessageId = Math.max(lastDmMessageId, msg.id);
        });
        if (messages.length > 0) {
            scrollToBottom(box);
        }
    }

    function sendDmMessage() {
        const receiverIdInput = document.getElementById('dm-receiver-id');
        const contentInput = document.getElementById('dm-input');

        const receiverId = receiverIdInput.value.trim();
        const content = contentInput.value.trim();

        if (!receiverId) {
            alert('수신자 사용자 ID를 입력해 주세요.');
            return;
        }
        if (!content) {
            return;
        }

        const payload = { content };

        // 아직 연결 안 됐으면 큐에 넣어두고, 연결만 시도
        if (!stompClient || !stompConnected) {
            console.log('STOMP 미연결 상태, 큐에 저장 후 연결 시도');
            pendingDmQueue.push({ receiverId, payload });
            if (!stompClient) {
                connectStomp();
            }
            contentInput.value = '';
            return;
        }

        stompClient.send(
            `/app/dm/${receiverId}/send`,
            {},
            JSON.stringify(payload)
        );
        contentInput.value = '';
    }

    function scrollToBottom(box) {
        box.scrollTop = box.scrollHeight;
    }

    function escapeHtml(str) {
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }
</script>


</body>
</html>
